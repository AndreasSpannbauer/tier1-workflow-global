#!/usr/bin/env python3
"""
ChatGPT Upload Helper - Simple file upload automation

Handles the boring parts:
1. Open browser and navigate to ChatGPT
2. Authenticate if needed (with gopass credentials)
3. Upload repomap and spec files

Then Claude takes over via MCP tools for:
- Sending prompts
- Waiting for response
- Parsing and extracting patches
- Applying changes

Usage:
    python3 tools/chatgpt_upload_helper.py --scope fullstack-review
    python3 tools/chatgpt_upload_helper.py --files repomap.txt spec.md

Author: Generated by Claude Code
Date: 2025-11-01
"""

import argparse
import asyncio
import json
import subprocess
import sys
from pathlib import Path
from typing import List, Optional

try:
    from mcp import ClientSession
    from mcp.client.streamable_http import streamablehttp_client
except ImportError:
    print("‚ùå MCP Python SDK not installed")
    print("   Install: pip install mcp")
    sys.exit(1)

# Configuration
MCP_SERVER_URL = "http://localhost:8931/mcp"
CHATGPT_URL = "https://chat.openai.com"


class ChatGPTUploadHelper:
    """Simple helper to open ChatGPT and upload files"""

    def __init__(self, mcp_url: str = MCP_SERVER_URL):
        self.mcp_url = mcp_url
        self.session: Optional[ClientSession] = None

    async def _mcp_call_tool(self, tool_name: str, arguments: dict) -> str:
        """Call an MCP tool and return the result"""
        if not self.session:
            raise RuntimeError("MCP session not initialized")

        result = await self.session.call_tool(tool_name, arguments)

        # Extract text content
        if hasattr(result, 'content') and result.content:
            for content_block in result.content:
                if hasattr(content_block, 'text'):
                    return content_block.text

        return str(result)

    def _run_command(self, cmd: List[str]) -> subprocess.CompletedProcess:
        """Run shell command"""
        return subprocess.run(cmd, capture_output=True, text=True, check=True)

    def _get_gopass_secret(self, key: str) -> str:
        """Retrieve secret from gopass"""
        result = self._run_command(["gopass", "show", key])
        return result.stdout.strip()

    async def open_and_authenticate(self) -> bool:
        """
        Open ChatGPT and authenticate if needed

        Returns:
            bool: True if ready for file upload
        """
        print("üåê Opening ChatGPT...")

        # Navigate to ChatGPT
        await self._mcp_call_tool("browser_navigate", {"url": CHATGPT_URL})
        await asyncio.sleep(2)

        # Take snapshot to check authentication
        snapshot = await self._mcp_call_tool("browser_snapshot", {})
        snapshot_lower = snapshot.lower()

        # Check if already logged in
        logged_in = any(indicator in snapshot_lower for indicator in [
            "upgrade plan", "my plan", "log out", "new chat", "settings"
        ])

        if logged_in:
            print("   ‚úì Already authenticated")
            return True

        print("   ‚Üí Not logged in, attempting authentication...")

        # Get credentials
        try:
            username = self._get_gopass_secret("chatgpt_user")
            password = self._get_gopass_secret("chatgpt_pw")
            print(f"   ‚Üí Retrieved credentials for {username}")
        except subprocess.CalledProcessError:
            print("   ‚ö†Ô∏è  Could not retrieve credentials from gopass")
            print("   ‚Üí Please authenticate manually in the browser")
            input("   Press Enter when logged in...")
            return True

        # Attempt automated login (basic flow)
        # Note: This may need manual intervention for 2FA
        print("   ‚Üí Attempting automated login...")
        print("   ‚è∏Ô∏è  If 2FA is required, complete it manually")
        print("   ‚Üí Claude will resume after you're logged in")

        input("   Press Enter when authentication is complete...")
        return True

    async def upload_files(self, file_paths: List[str]) -> bool:
        """
        Upload files to ChatGPT

        Args:
            file_paths: Absolute paths to files to upload

        Returns:
            bool: True if upload initiated successfully
        """
        # Verify all files exist
        for path in file_paths:
            if not Path(path).exists():
                print(f"   ‚úó File not found: {path}")
                return False

        print(f"üì§ Uploading {len(file_paths)} file(s)...")
        for path in file_paths:
            size_mb = Path(path).stat().st_size / (1024 * 1024)
            print(f"   ‚Üí {Path(path).name} ({size_mb:.2f} MB)")

        try:
            # Upload files via MCP
            await self._mcp_call_tool("browser_file_upload", {
                "paths": file_paths
            })

            # Give it a moment to process
            await asyncio.sleep(2)

            print("   ‚úì Files uploaded")
            print()
            print("‚úÖ Setup complete! Claude will now take over for:")
            print("   - Generating and sending contextual prompt")
            print("   - Monitoring response completion")
            print("   - Extracting and applying patches")
            return True

        except Exception as e:
            print(f"   ‚úó Upload error: {e}")
            return False

    async def run(self, file_paths: List[str]) -> bool:
        """
        Complete workflow: open, authenticate, upload

        Args:
            file_paths: Files to upload

        Returns:
            bool: True if successful
        """
        print("üöÄ ChatGPT Upload Helper")
        print(f"   MCP Server: {self.mcp_url}")
        print()

        # Connect to MCP
        print("üîå Connecting to Playwright MCP...")
        try:
            async with streamablehttp_client(self.mcp_url) as (read_stream, write_stream, _):
                async with ClientSession(read_stream, write_stream) as session:
                    self.session = session
                    await session.initialize()

                    tools = await session.list_tools()
                    print(f"   ‚úì Connected - {len(tools.tools)} tools available")
                    print()

                    # Step 1: Open and authenticate
                    if not await self.open_and_authenticate():
                        return False

                    # Step 2: Upload files
                    if not await self.upload_files(file_paths):
                        return False

                    return True

        except Exception as e:
            print(f"‚ùå MCP connection error: {e}")
            print("   ‚Üí Ensure Playwright MCP is running:")
            print("      ~/bin/start-playwright-extension.sh")
            return False


def generate_repomap(scope: str) -> Optional[str]:
    """
    Generate repomap and return path

    Args:
        scope: Repomap scope

    Returns:
        str: Absolute path to generated repomap, or None on error
    """
    print(f"üìä Generating repomap (scope: {scope})...")

    cmd = [
        "python3",
        "tools/generate_scoped_repomap.py",
        "--scope", scope,
        "--engine", "auto"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)

        # Find generated file path in output
        for line in result.stdout.split('\n'):
            if "Generated:" in line and ".txt" in line:
                path = line.split("Generated:")[1].strip()
                if Path(path).exists():
                    print(f"   ‚úì Generated: {path}")
                    return str(Path(path).absolute())

        # Fallback: find most recent
        repomaps_dir = Path("repomaps")
        if repomaps_dir.exists():
            repomap_files = sorted(
                repomaps_dir.glob("**/repomap-*.txt"),
                key=lambda p: p.stat().st_mtime
            )
            if repomap_files:
                path = str(repomap_files[-1].absolute())
                print(f"   ‚úì Found: {path}")
                return path

        print("   ‚úó Could not locate generated repomap")
        return None

    except subprocess.CalledProcessError as e:
        print(f"   ‚úó Generation failed: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(
        description="ChatGPT Upload Helper - Open browser and upload files"
    )
    parser.add_argument(
        "--scope",
        help="Generate repomap with this scope and upload (e.g., fullstack-review, backend)"
    )
    parser.add_argument(
        "--files",
        nargs="+",
        help="Files to upload (absolute or relative paths)"
    )
    parser.add_argument(
        "--mcp-url",
        default=MCP_SERVER_URL,
        help=f"Playwright MCP server URL (default: {MCP_SERVER_URL})"
    )

    args = parser.parse_args()

    # Build file list
    files_to_upload = []

    # Option 1: Generate repomap
    if args.scope:
        repomap_path = generate_repomap(args.scope)
        if repomap_path:
            files_to_upload.append(repomap_path)
        else:
            print("‚ùå Repomap generation failed")
            sys.exit(1)

        # Also include MASTER_SPEC if it exists
        master_spec = Path(".tasks/MASTER_SPEC.md")
        if master_spec.exists():
            files_to_upload.append(str(master_spec.absolute()))
            print(f"   ‚úì Including MASTER_SPEC.md")

    # Option 2: Explicit file list
    if args.files:
        for file_path in args.files:
            abs_path = Path(file_path).absolute()
            if abs_path.exists():
                files_to_upload.append(str(abs_path))
            else:
                print(f"‚ùå File not found: {file_path}")
                sys.exit(1)

    # Validate we have files to upload
    if not files_to_upload:
        print("‚ùå No files to upload")
        print("   Use --scope to generate repomap or --files to specify files")
        parser.print_help()
        sys.exit(1)

    # Remove duplicates while preserving order
    files_to_upload = list(dict.fromkeys(files_to_upload))

    # Run upload
    helper = ChatGPTUploadHelper(mcp_url=args.mcp_url)

    try:
        success = asyncio.run(helper.run(files_to_upload))
        sys.exit(0 if success else 1)

    except KeyboardInterrupt:
        print("\n‚è∏Ô∏è  Interrupted")
        sys.exit(130)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
