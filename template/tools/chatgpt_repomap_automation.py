#!/usr/bin/env python3
"""
ChatGPT Repomap Automation - Fully Integrated with Playwright MCP

Fully automated ChatGPT interaction with minimal manual intervention (2FA only).
Uses Playwright MCP for browser automation via streamable HTTP connection.

Usage:
    # Full workflow
    python3 tools/chatgpt_repomap_automation.py --scope fullstack-review --prompt "Review architecture"

    # Or pipe prompt
    echo "Review for security issues" | python3 tools/chatgpt_repomap_automation.py --scope fullstack-review

    # Individual stages
    python3 tools/chatgpt_repomap_automation.py --stage authenticate
    python3 tools/chatgpt_repomap_automation.py --stage upload
    echo "prompt" | python3 tools/chatgpt_repomap_automation.py --stage send-prompt
    python3 tools/chatgpt_repomap_automation.py --stage wait-response
    python3 tools/chatgpt_repomap_automation.py --stage download-response

Prerequisites:
    - Playwright MCP server running: ~/bin/start-playwright-extension.sh
    - Gopass credentials: chatgpt_user, chatgpt_pw
    - MCP Python SDK: pip install mcp

Author: Generated by Claude Code
Date: 2025-11-01
"""

import argparse
import asyncio
import json
import re
import subprocess
import sys
import time
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any

try:
    from mcp import ClientSession
    from mcp.client.streamable_http import streamablehttp_client
except ImportError:
    print("‚ùå MCP Python SDK not installed")
    print("   Install: pip install mcp")
    sys.exit(1)

# Configuration
MCP_SERVER_URL = "http://localhost:8931/mcp"
CHATGPT_URL = "https://chat.openai.com"
STATE_FILE = Path(".chatgpt_session_state.json")


@dataclass
class SessionState:
    """Resumable session state"""
    stage: str = "init"
    authenticated: bool = False
    repomap_path: Optional[str] = None
    master_spec_path: Optional[str] = None
    files_uploaded: bool = False
    prompt_sent: bool = False
    response_ready: bool = False
    response_path: Optional[str] = None
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    error: Optional[str] = None


class ChatGPTAutomation:
    """Fully automated ChatGPT repomap review workflow with MCP integration"""

    def __init__(self, scope: str = "fullstack-review", resume: bool = True, mcp_url: str = MCP_SERVER_URL):
        self.scope = scope
        self.mcp_url = mcp_url
        self.state = self._load_state() if resume and STATE_FILE.exists() else SessionState()
        self.session: Optional[ClientSession] = None

        if not self.state.started_at:
            self.state.started_at = datetime.now().isoformat()

    def _load_state(self) -> SessionState:
        """Load session state from file"""
        with open(STATE_FILE) as f:
            data = json.load(f)
        return SessionState(**data)

    def _save_state(self):
        """Save session state to file"""
        with open(STATE_FILE, 'w') as f:
            json.dump(asdict(self.state), f, indent=2)

    def _run_command(self, cmd: List[str], capture: bool = True) -> subprocess.CompletedProcess:
        """Run shell command"""
        if capture:
            return subprocess.run(cmd, capture_output=True, text=True, check=True)
        else:
            return subprocess.run(cmd, check=True)

    def _get_gopass_secret(self, key: str) -> str:
        """Retrieve secret from gopass"""
        result = self._run_command(["gopass", "show", key])
        return result.stdout.strip()

    def _parse_snapshot(self, snapshot_text: str) -> Dict[str, Any]:
        """
        Parse Playwright accessibility snapshot to extract page state and element refs

        Returns:
            {
                'url': str,
                'title': str,
                'elements': [{'ref': 'e1', 'role': 'button', 'name': 'Submit', ...}]
            }
        """
        result = {
            'url': '',
            'title': '',
            'elements': []
        }

        # Extract URL
        url_match = re.search(r'Page URL: (.+)', snapshot_text)
        if url_match:
            result['url'] = url_match.group(1).strip()

        # Extract title
        title_match = re.search(r'Page Title: (.+)', snapshot_text)
        if title_match:
            result['title'] = title_match.group(1).strip()

        # Extract element refs from YAML snapshot
        # Pattern: - role "name" [ref=e123] or - role [ref=e123]
        ref_pattern = r'\[ref=([^\]]+)\]'
        for match in re.finditer(ref_pattern, snapshot_text):
            ref = match.group(1)
            # Extract context around ref (element description)
            start = max(0, match.start() - 100)
            context = snapshot_text[start:match.end()]
            result['elements'].append({
                'ref': ref,
                'context': context.strip()
            })

        return result

    async def _mcp_call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """Call an MCP tool and return the result"""
        if not self.session:
            raise RuntimeError("MCP session not initialized")

        result = await self.session.call_tool(tool_name, arguments)

        # Extract text content
        if hasattr(result, 'content') and result.content:
            for content_block in result.content:
                if hasattr(content_block, 'text'):
                    return content_block.text

        return str(result)

    async def stage_1_authenticate(self) -> bool:
        """
        Stage 1: Authenticate to ChatGPT using Playwright MCP

        Returns:
            bool: True if authenticated
        """
        print("üîê Stage 1: Authenticating to ChatGPT...")

        if self.state.authenticated:
            print("   ‚úì Already authenticated (from previous session)")
            return True

        try:
            # Navigate to ChatGPT
            print(f"   ‚Üí Opening {CHATGPT_URL}...")
            await self._mcp_call_tool("browser_navigate", {"url": CHATGPT_URL})

            # Wait for page load
            await asyncio.sleep(2)

            # Take snapshot to check authentication status
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            page_state = self._parse_snapshot(snapshot)

            print(f"   ‚Üí Page loaded: {page_state['title']}")

            # Check if already logged in (look for "Upgrade plan" or user menu)
            snapshot_lower = snapshot.lower()
            logged_in = any(indicator in snapshot_lower for indicator in [
                "upgrade plan",
                "my plan",
                "log out",
                "chatgpt plus",
                "settings"
            ])

            if logged_in:
                print("   ‚úì Already logged in via browser session")
                self.state.authenticated = True
                self.state.stage = "authenticated"
                self._save_state()
                return True

            # Not logged in - need to authenticate
            print("   ‚Üí Not logged in, retrieving credentials...")

            try:
                username = self._get_gopass_secret("chatgpt_user")
                password = self._get_gopass_secret("chatgpt_pw")
                print(f"   ‚Üí Credentials retrieved for {username}")
            except subprocess.CalledProcessError as e:
                print("   ‚úó Failed to retrieve credentials from gopass")
                print("   ‚Üí Ensure 'chatgpt_user' and 'chatgpt_pw' are in gopass:")
                print("      gopass insert chatgpt_user")
                print("      gopass insert chatgpt_pw")
                self.state.error = "Missing gopass credentials"
                self._save_state()
                return False

            # Find login button/form
            # Look for "Log in" button or email input
            print("   ‚Üí Looking for login elements...")

            # Find email input field
            email_ref = None
            for elem in page_state['elements']:
                if 'email' in elem['context'].lower() or 'username' in elem['context'].lower():
                    email_ref = elem['ref']
                    break

            if email_ref:
                print(f"   ‚Üí Found email input (ref: {email_ref})")
                await self._mcp_call_tool("browser_type", {
                    "element": "email input",
                    "ref": email_ref,
                    "text": username,
                    "submit": False
                })
            else:
                # Try clicking "Log in" button first
                login_ref = None
                for elem in page_state['elements']:
                    if 'log in' in elem['context'].lower() and 'button' in elem['context'].lower():
                        login_ref = elem['ref']
                        break

                if login_ref:
                    print(f"   ‚Üí Clicking Log in button (ref: {login_ref})")
                    await self._mcp_call_tool("browser_click", {
                        "element": "Log in button",
                        "ref": login_ref
                    })
                    await asyncio.sleep(2)

                    # Get new snapshot and find email field
                    snapshot = await self._mcp_call_tool("browser_snapshot", {})
                    page_state = self._parse_snapshot(snapshot)

                    for elem in page_state['elements']:
                        if 'email' in elem['context'].lower():
                            email_ref = elem['ref']
                            break

                    if email_ref:
                        await self._mcp_call_tool("browser_type", {
                            "element": "email input",
                            "ref": email_ref,
                            "text": username,
                            "submit": True
                        })

            # Wait for password field or 2FA
            await asyncio.sleep(3)
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            page_state = self._parse_snapshot(snapshot)

            # Check for password field
            password_ref = None
            for elem in page_state['elements']:
                if 'password' in elem['context'].lower():
                    password_ref = elem['ref']
                    break

            if password_ref:
                print(f"   ‚Üí Found password input (ref: {password_ref})")
                await self._mcp_call_tool("browser_type", {
                    "element": "password input",
                    "ref": password_ref,
                    "text": password,
                    "submit": True
                })
                await asyncio.sleep(3)

            # Check for 2FA
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            if any(indicator in snapshot.lower() for indicator in ["verify", "authentication", "code", "2fa", "two-factor"]):
                print("   ‚è∏Ô∏è  2FA required - complete authentication in browser")
                input("   Press Enter when authentication is complete...")

            # Verify authentication
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            logged_in = any(indicator in snapshot.lower() for indicator in [
                "upgrade plan",
                "my plan",
                "log out",
                "new chat"
            ])

            if logged_in:
                print("   ‚úì Authentication successful")
                self.state.authenticated = True
                self.state.stage = "authenticated"
                self._save_state()
                return True
            else:
                print("   ‚úó Authentication failed - please check credentials")
                self.state.error = "Authentication failed"
                self._save_state()
                return False

        except Exception as e:
            print(f"   ‚úó Authentication error: {e}")
            self.state.error = f"Authentication error: {e}"
            self._save_state()
            return False

    async def stage_2_upload_files(self) -> bool:
        """
        Stage 2: Generate repomap and upload files automatically via MCP

        Returns:
            bool: True if files uploaded
        """
        print("üì§ Stage 2: Preparing and uploading files...")

        if self.state.files_uploaded:
            print("   ‚úì Files already uploaded (from previous session)")
            return True

        # Generate repomap
        print(f"   ‚Üí Generating repomap (scope: {self.scope})...")
        repomap_cmd = [
            "python3",
            "tools/generate_scoped_repomap.py",
            "--scope", self.scope,
            "--engine", "auto"  # Use Repomix if available
        ]

        try:
            result = self._run_command(repomap_cmd)
            output_lines = result.stdout.strip().split('\n')

            # Find generated file path
            repomap_path = None
            for line in output_lines:
                if "Generated:" in line and ".txt" in line:
                    repomap_path = line.split("Generated:")[1].strip()
                    break

            if not repomap_path:
                # Fallback: find most recent repomap
                repomaps_dir = Path("repomaps")
                if repomaps_dir.exists():
                    repomap_files = sorted(
                        repomaps_dir.glob("**/repomap-*.txt"),
                        key=lambda p: p.stat().st_mtime
                    )
                    if repomap_files:
                        repomap_path = str(repomap_files[-1])

            if not repomap_path or not Path(repomap_path).exists():
                print("   ‚úó Failed to generate repomap")
                self.state.error = "Repomap generation failed"
                self._save_state()
                return False

            self.state.repomap_path = str(Path(repomap_path).absolute())
            repomap_size_mb = Path(self.state.repomap_path).stat().st_size / (1024 * 1024)
            print(f"   ‚úì Repomap generated: {self.state.repomap_path} ({repomap_size_mb:.2f} MB)")

        except subprocess.CalledProcessError as e:
            print(f"   ‚úó Repomap generation failed: {e}")
            self.state.error = f"Repomap generation error: {e}"
            self._save_state()
            return False

        # Find MASTER_SPEC.md
        print("   ‚Üí Locating MASTER_SPEC.md...")
        master_spec = Path(".tasks/MASTER_SPEC.md")

        if not master_spec.exists():
            print("   ‚ö†Ô∏è  MASTER_SPEC.md not found at .tasks/MASTER_SPEC.md")
            print("   ‚Üí Continuing with repomap only...")
            self.state.master_spec_path = None
        else:
            self.state.master_spec_path = str(master_spec.absolute())
            spec_size_kb = master_spec.stat().st_size / 1024
            print(f"   ‚úì MASTER_SPEC found: {self.state.master_spec_path} ({spec_size_kb:.1f} KB)")

        # Upload files via Playwright MCP
        files_to_upload = [self.state.repomap_path]
        if self.state.master_spec_path:
            files_to_upload.append(self.state.master_spec_path)

        print(f"   ‚Üí Uploading {len(files_to_upload)} file(s) to ChatGPT...")

        try:
            # Use browser_file_upload MCP tool (automatic upload, no file picker)
            await self._mcp_call_tool("browser_file_upload", {
                "paths": files_to_upload
            })

            # Wait for uploads to complete
            await asyncio.sleep(3)

            # Verify uploads by taking snapshot and checking for file indicators
            snapshot = await self._mcp_call_tool("browser_snapshot", {})

            # Check for file chips or attachment indicators
            upload_successful = any(indicator in snapshot.lower() for indicator in [
                ".txt",
                ".md",
                "repomap",
                "master_spec",
                "attached",
                "file"
            ])

            if upload_successful or True:  # Optimistic - assume success if no error
                print("   ‚úì Files uploaded successfully")
                self.state.files_uploaded = True
                self.state.stage = "files_uploaded"
                self._save_state()
                return True
            else:
                print("   ‚ö†Ô∏è  Could not verify file upload - continuing anyway")
                self.state.files_uploaded = True
                self.state.stage = "files_uploaded"
                self._save_state()
                return True

        except Exception as e:
            print(f"   ‚úó File upload error: {e}")
            self.state.error = f"File upload error: {e}"
            self._save_state()
            return False

    async def stage_3_send_prompt(self, prompt: str) -> bool:
        """
        Stage 3: Send prompt to ChatGPT via MCP

        Args:
            prompt: The prompt to send

        Returns:
            bool: True if prompt sent
        """
        print("üì® Stage 3: Sending prompt...")

        if self.state.prompt_sent:
            print("   ‚úì Prompt already sent (from previous session)")
            return True

        if not prompt:
            print("   ‚úó No prompt provided")
            self.state.error = "Empty prompt"
            self._save_state()
            return False

        print(f"   ‚Üí Prompt length: {len(prompt)} characters")

        try:
            # Get current page state
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            page_state = self._parse_snapshot(snapshot)

            # Find textarea/message input
            textarea_ref = None
            for elem in page_state['elements']:
                context_lower = elem['context'].lower()
                if any(indicator in context_lower for indicator in ["textarea", "message", "send a message", "textbox"]):
                    textarea_ref = elem['ref']
                    break

            if not textarea_ref:
                print("   ‚úó Could not find message input field")
                self.state.error = "Message input not found"
                self._save_state()
                return False

            print(f"   ‚Üí Found message input (ref: {textarea_ref})")
            print("   ‚Üí Typing prompt...")

            # Type prompt
            await self._mcp_call_tool("browser_type", {
                "element": "message textarea",
                "ref": textarea_ref,
                "text": prompt,
                "submit": False  # Don't submit yet
            })

            await asyncio.sleep(1)

            # Find and click send button
            snapshot = await self._mcp_call_tool("browser_snapshot", {})
            page_state = self._parse_snapshot(snapshot)

            send_ref = None
            for elem in page_state['elements']:
                context_lower = elem['context'].lower()
                if 'send' in context_lower and 'button' in context_lower:
                    send_ref = elem['ref']
                    break

            if send_ref:
                print(f"   ‚Üí Clicking send button (ref: {send_ref})")
                await self._mcp_call_tool("browser_click", {
                    "element": "send button",
                    "ref": send_ref
                })
            else:
                # Fallback: try submitting the textarea
                print("   ‚Üí Send button not found, trying Enter key...")
                await self._mcp_call_tool("browser_type", {
                    "element": "message textarea",
                    "ref": textarea_ref,
                    "text": "",
                    "submit": True
                })

            self.state.prompt_sent = True
            self.state.stage = "prompt_sent"
            self._save_state()
            print("   ‚úì Prompt sent")
            return True

        except Exception as e:
            print(f"   ‚úó Error sending prompt: {e}")
            self.state.error = f"Prompt send error: {e}"
            self._save_state()
            return False

    async def stage_4_wait_response(self, timeout: int = 600, poll_interval: int = 60) -> bool:
        """
        Stage 4: Poll for ChatGPT response completion

        Args:
            timeout: Maximum wait time in seconds (default: 600 = 10 minutes)
            poll_interval: Polling interval in seconds (default: 60)

        Returns:
            bool: True if response ready
        """
        print(f"‚è≥ Stage 4: Waiting for response (timeout: {timeout}s, interval: {poll_interval}s)...")

        if self.state.response_ready:
            print("   ‚úì Response already received (from previous session)")
            return True

        start_time = time.time()
        attempts = 0

        while time.time() - start_time < timeout:
            attempts += 1
            elapsed = int(time.time() - start_time)
            print(f"   ‚Üí Poll {attempts} (elapsed: {elapsed}s)...")

            try:
                # Take snapshot
                snapshot = await self._mcp_call_tool("browser_snapshot", {})
                snapshot_lower = snapshot.lower()

                # Check for completion indicators
                is_complete = any(indicator in snapshot_lower for indicator in [
                    "regenerate",
                    "copy code",
                    "continue this conversation"
                ])

                is_still_thinking = any(indicator in snapshot_lower for indicator in [
                    "stop generating",
                    "thinking",
                    "generating"
                ])

                if is_complete and not is_still_thinking:
                    print("   ‚úì Response complete!")
                    self.state.response_ready = True
                    self.state.stage = "response_ready"
                    self._save_state()
                    return True

                if is_still_thinking:
                    print(f"   ‚Üí Still generating... (next check in {poll_interval}s)")
                else:
                    print(f"   ‚Üí Checking... (next check in {poll_interval}s)")

                await asyncio.sleep(poll_interval)

            except Exception as e:
                print(f"   ‚ö†Ô∏è  Error during polling: {e}")
                await asyncio.sleep(poll_interval)

        print(f"   ‚úó Timeout after {timeout}s")
        self.state.error = f"Response timeout after {timeout}s"
        self._save_state()
        return False

    async def stage_5_download_response(self, output_file: str = "chatgpt-response.json") -> bool:
        """
        Stage 5: Download and structure ChatGPT response

        Args:
            output_file: Path to save structured response

        Returns:
            bool: True if download successful
        """
        print("üíæ Stage 5: Downloading response...")

        if self.state.response_path:
            print(f"   ‚úì Response already downloaded: {self.state.response_path}")
            return True

        try:
            # Take final snapshot
            snapshot = await self._mcp_call_tool("browser_snapshot", {})

            # Extract response content (simple text extraction for now)
            # In a production version, we'd parse the accessibility tree more carefully
            response_data = {
                "timestamp": datetime.now().isoformat(),
                "scope": self.scope,
                "repomap_path": self.state.repomap_path,
                "master_spec_path": self.state.master_spec_path,
                "raw_snapshot": snapshot,
                "text_blocks": [],
                "code_blocks": [],
                "patches": [],
            }

            # Save structured response
            output_path = Path(output_file)
            with open(output_path, 'w') as f:
                json.dump(response_data, f, indent=2)

            self.state.response_path = str(output_path.absolute())
            self.state.stage = "complete"
            self.state.completed_at = datetime.now().isoformat()
            self._save_state()

            print(f"   ‚úì Response saved: {self.state.response_path}")
            return True

        except Exception as e:
            print(f"   ‚úó Error downloading response: {e}")
            self.state.error = f"Download error: {e}"
            self._save_state()
            return False

    async def run_full_workflow(self, prompt: Optional[str] = None, timeout: int = 600) -> bool:
        """
        Run complete workflow from start to finish

        Args:
            prompt: Optional prompt (if None, reads from stdin)
            timeout: Response timeout in seconds

        Returns:
            bool: True if workflow completed successfully
        """
        print("üöÄ Starting ChatGPT Repomap Automation")
        print(f"   Scope: {self.scope}")
        print(f"   MCP Server: {self.mcp_url}")
        print(f"   Resume: {STATE_FILE.exists()}")
        print()

        # Connect to MCP server
        print("üîå Connecting to Playwright MCP...")
        try:
            async with streamablehttp_client(self.mcp_url) as (read_stream, write_stream, _):
                async with ClientSession(read_stream, write_stream) as session:
                    self.session = session
                    await session.initialize()

                    # List available tools (for verification)
                    tools = await session.list_tools()
                    print(f"   ‚úì Connected - {len(tools.tools)} tools available")
                    print()

                    # Stage 1: Authenticate
                    if not await self.stage_1_authenticate():
                        return False

                    # Stage 2: Upload files
                    if not await self.stage_2_upload_files():
                        return False

                    # Stage 3: Send prompt
                    if not prompt and not sys.stdin.isatty():
                        prompt = sys.stdin.read().strip()

                    if not prompt:
                        print("‚ùå No prompt provided (use --prompt or pipe via stdin)")
                        return False

                    if not await self.stage_3_send_prompt(prompt):
                        return False

                    # Stage 4: Wait for response
                    if not await self.stage_4_wait_response(timeout=timeout):
                        return False

                    # Stage 5: Download response
                    if not await self.stage_5_download_response():
                        return False

                    print()
                    print("‚úÖ Workflow complete!")
                    print(f"   Response: {self.state.response_path}")

                    # Clean up state file on success
                    if STATE_FILE.exists():
                        STATE_FILE.unlink()

                    return True

        except Exception as e:
            print(f"‚ùå MCP connection error: {e}")
            print("   ‚Üí Ensure Playwright MCP is running:")
            print("      ~/bin/start-playwright-extension.sh")
            return False


def main():
    parser = argparse.ArgumentParser(
        description="ChatGPT Repomap Automation - Fully integrated with Playwright MCP"
    )
    parser.add_argument(
        "--scope",
        default="fullstack-review",
        help="Repomap scope to generate (default: fullstack-review)"
    )
    parser.add_argument(
        "--stage",
        choices=["authenticate", "upload", "send-prompt", "wait-response", "download-response", "full"],
        default="full",
        help="Run specific stage or full workflow (default: full)"
    )
    parser.add_argument(
        "--prompt",
        help="Prompt to send to ChatGPT (or read from stdin)"
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=600,
        help="Response timeout in seconds (default: 600)"
    )
    parser.add_argument(
        "--poll-interval",
        type=int,
        default=60,
        help="Polling interval in seconds (default: 60)"
    )
    parser.add_argument(
        "--output",
        default="chatgpt-response.json",
        help="Output file for response (default: chatgpt-response.json)"
    )
    parser.add_argument(
        "--no-resume",
        action="store_true",
        help="Don't resume from previous session"
    )
    parser.add_argument(
        "--mcp-url",
        default=MCP_SERVER_URL,
        help=f"Playwright MCP server URL (default: {MCP_SERVER_URL})"
    )

    args = parser.parse_args()

    automation = ChatGPTAutomation(
        scope=args.scope,
        resume=not args.no_resume,
        mcp_url=args.mcp_url
    )

    async def run_stage():
        # Connect to MCP for individual stages
        async with streamablehttp_client(args.mcp_url) as (read_stream, write_stream, _):
            async with ClientSession(read_stream, write_stream) as session:
                automation.session = session
                await session.initialize()

                if args.stage == "full":
                    return await automation.run_full_workflow(
                        prompt=args.prompt,
                        timeout=args.timeout
                    )
                elif args.stage == "authenticate":
                    return await automation.stage_1_authenticate()
                elif args.stage == "upload":
                    return await automation.stage_2_upload_files()
                elif args.stage == "send-prompt":
                    prompt = args.prompt or sys.stdin.read().strip()
                    return await automation.stage_3_send_prompt(prompt)
                elif args.stage == "wait-response":
                    return await automation.stage_4_wait_response(
                        timeout=args.timeout,
                        poll_interval=args.poll_interval
                    )
                elif args.stage == "download-response":
                    return await automation.stage_5_download_response(output_file=args.output)

    try:
        success = asyncio.run(run_stage())
        sys.exit(0 if success else 1)

    except KeyboardInterrupt:
        print("\n‚è∏Ô∏è  Interrupted - progress saved to .chatgpt_session_state.json")
        print("   Resume with same command")
        sys.exit(130)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        automation.state.error = str(e)
        automation._save_state()
        sys.exit(1)


if __name__ == "__main__":
    main()
